<!--
*Pydantic* allows auto creation of JSON Schemas from models:
-->
*pydantic* ではモデルから JSON スキーマを自動生成できます:

```py
{!.tmp_examples/schema_main.py!}
```

<!--
_(This script is complete, it should run "as is")_
-->
_(このスクリプトは完成しています。「そのまま」実行する必要があります)_

<!--
Outputs:
-->
出力:

```json
{!.tmp_examples/schema_main.json!}
```

<!--
The generated schemas are compliant with the specifications:
[JSON Schema Core](https://json-schema.org/latest/json-schema-core.html),
[JSON Schema Validation](https://json-schema.org/latest/json-schema-validation.html) and
[OpenAPI](https://github.com/OAI/OpenAPI-Specification).
-->
生成されたスキーマは、
[JSON スキーマコア](https://json-schema.org/latest/json-schema-core.html)、
[JSON スキーマ検証](https://json-schema.org/latest/json-schema-validation.html)、
[OpenAPI](https://github.com/OAI/OpenAPI-Specification) の使用に準拠しています。

<!--
`BaseModel.schema` will return a dict of the schema, while `BaseModel.schema_json` will return a JSON string
representation of that dict.
-->
`BaseModel.schema` はスキーマの `dict` を返し、`BaseModel.schema_json` はその辞書の JSON 文字列を返します。

<!--
Sub-models used are added to the `definitions` JSON attribute and referenced, as per the spec.
-->
使用されるサブモデルは仕様に従って `definitions` JSON 属性に追加され、参照されます。

<!--
All sub-models' (and their sub-models') schemas are put directly in a top-level `definitions` JSON key for easy re-use
and reference.
-->
すべてのサブモデル(およびそのサブモデル)のスキーマは、再利用や参照を容易にするために、トップレベルの `definitions` JSON キーに直接格納されます。

<!--
"Sub-models" with modifications (via the `Field` class) like a custom title, description or default value,
are recursively included instead of referenced.
-->
`Field` クラスを介して title、description、デフォルト値に変更を加えた "サブモデル" は、参照される代わりに再帰的に含まれます。

<!--
The `description` for models is taken from either the docstring of the class or the argument `description` to
the `Field` class.
-->
モデルの `description` は、クラスの docstring または `Field` クラスの引数の `description` から取得されます。

<!--
The schema is generated by default using aliases as keys, but it can be generated using model
property names instead by calling `MainModel.schema/schema_json(by_alias=False)`.
-->
スキーマはデフォルトでエイリアスをキーとして使用して生成されますが、
`MainModel.schema/schema_json(by_alias=False)` を呼び出す代わりにモデルプロパティ名を使用して生成できます。

<!--
## Field customisation
-->
## フィールドのカスタマイズ

<!--
Optionally, the `Field` function can be used to provide extra information about the field and validations.
It has the following arguments:
-->
オプションで、`Field` 関数を使用してフィールドとバリデーションに関する追加情報を提供できます。
次のような引数があります:

<!--
* `default`: (a positional argument) the default value of the field.
    Since the `Field` replaces the field's default, this first argument can be used to set the default.
    Use ellipsis (`...`) to indicate the field is required.
-->
* `default`: (位置引数) フィールドのデフォルト値。
  `Field` はフィールドのデフォルトを置き換えるため、この最初の引数を使用してデフォルトを設定できます。
  省略記号 (...) を使用して、フィールドが必須であることを示します。

<!--
* `default_factory`: a zero-argument callable that will be called when a default value is needed for this field.
    Among other purposes, this can be used to set dynamic default values.
    It is forbidden to set both `default` and `default_factory`.
-->
* `default_factory`: このフィールドにデフォルト値が必要なときに呼び出される、引数なしの呼び出し可能オブジェクト。
  他の目的でもこれを使用して動的なデフォルト値を設定できます。`default` と `default_factory` の両方を設定することは禁止されています。

<!--
* `alias`: the public name of the field
-->
* `alias`: フィールドのパブリックネーム。

<!--
* `title`: if omitted, `field_name.title()` is used
-->
* `title`: 省略した場合、`field_name.title()` が使用されます。

<!--
* `description`: if omitted and the annotation is a sub-model,
    the docstring of the sub-model will be used
-->
* `description`: 省略され、かつアノテーションがサブモデルの場合、サブモデルの docstring が使用されます。

<!--
* `const`: this argument *must* be the same as the field's default value if present.
-->
* `const`: 存在する場合、この引数はフィールドのデフォルト値と同じで*なければなりません*。

<!--
* `gt`: for numeric values (``int``, `float`, `Decimal`), adds a validation of "greater than" and an annotation
  of `exclusiveMinimum` to the JSON Schema
-->
* `gt`: 数値(`int`、`float`、`Decimal`)への、"greater than" (〜より大きい)のバリデーションと、
  JSON スキーマへの `exclusiveMinimum` のアノテーションの追加を行います。

<!--
* `ge`: for numeric values, this adds a validation of "greater than or equal" and an annotation of `minimum` to the
  JSON Schema
-->
* `ge`: 数値への "greater than or equal" (〜以上)のバリデーションと、
  JSON スキーマへの `minimum` のアノテーションの追加を行います。

<!--
* `lt`: for numeric values, this adds a validation of "less than" and an annotation of `exclusiveMaximum` to the
  JSON Schema
-->
* `lt`: 数値への "less than" (〜より小さい)のバリデーションと、
  JSON スキーマへの `exclusiveMaximum` のアノテーションの追加を行います。

<!--
* `le`: for numeric values, this adds a validation of "less than or equal" and an annotation of `maximum` to the
  JSON Schema
-->
* `le`: 数値への "less than or equal" (〜以下)のバリデーションと、
  JSON スキーマへの `maximum` のアノテーションの追加を行います。

<!--
* `multiple_of`: for numeric values, this adds a validation of "a multiple of" and an annotation of `multipleOf` to the
  JSON Schema
-->
* `multiple_of`: 数値への "a multiple of" (〜の倍数)のバリデーションと、
  JSON スキーマへの `multipleOf` のアノテーションの追加を行います。

<!--
* `min_items`: for list values, this adds a corresponding validation and an annotation of `minItems` to the
  JSON Schema
-->
* `min_items`: リスト値に対応するバリデーションと、
  JSON スキーマへの `minItems` のアノテーションの追加を行います。

<!--
* `max_items`: for list values, this adds a corresponding validation and an annotation of `maxItems` to the
  JSON Schema
-->
* `max_items`: リスト値に対応するバリデーションと、
  JSON スキーマへの `maxItems` のアノテーションの追加を行います。

<!--
* `min_length`: for string values, this adds a corresponding validation and an annotation of `minLength` to the
  JSON Schema
-->
* `min_length`: 文字列に対応するバリデーションと、
  JSON スキーマへの `minLength` のアノテーションの追加を行います。

<!--
* `max_length`: for string values, this adds a corresponding validation and an annotation of `maxLength` to the
  JSON Schema
-->
* `max_length`: 文字列に対応するバリデーションと、
  JSON スキーマへの `maxLength` のアノテーションの追加を行います。

<!--
* `regex`: for string values, this adds a Regular Expression validation generated from the passed string and an
  annotation of `pattern` to the JSON Schema
-->
* `regex`: 文字列に、渡された文字列から生成された正規表現検証と、
  JSON スキーマへの `pattern` のアノテーションを追加を行います。

<!--
    !!! note
        *pydantic* validates strings using `re.match`,
        which treats regular expressions as implicitly anchored at the beginning.
        On the contrary,
        JSON Schema validators treat the `pattern` keyword as implicitly unanchored,
        more like what `re.search` does.

        For interoperability, depending on your desired behavior,
        either explicitly anchor your regular expressions with `^`
        (e.g. `^foo` to match any string starting with `foo`),
        or explicitly allow an arbitrary prefix with `.*?`
        (e.g. `.*?foo` to match any string containing the substring `foo`).

        See [#1631](https://github.com/samuelcolvin/pydantic/issues/1631)
        for a discussion of possible changes to *pydantic* behavior in **v2**.
-->
    !!! note
        *pydantic* は、正規表現を最初に暗黙的に固定されたものとして扱う `re.match` を使用して文字列を検証します。
        逆に JSON スキーマバリデーターは、`re.search` が行うように、`pattern` キーワードを暗黙的にアンカーされていないものとして扱います。

        相互運用性のため必要な動作に応じて、正規表現を `^` で明示的に固定する(例: `^foo` は `foo` で始まる任意の文字列に一致します)か、
        `.*?` で任意のプレフィックスを明示的に許可します(例: `.*?foo` は、部分文字列 `foo` を含む任意の文字列と一致します)。

<!--
* `**` any other keyword arguments (e.g. `examples`) will be added verbatim to the field's schema
-->
* `**` その他のキーワード引数(例: `examples`)は、フィールドのスキーマに逐語的に追加されます。

<!--
Instead of using `Field`, the `fields` property of [the Config class](model_config.md) can be used
to set all of the arguments above except `default`.
-->
`Field` を使用する代わりに [Config クラス](model_config.md)の `fields` プロパティを使用して、
`default` を除く上記のすべての引数を設定できます。

### Unenforced Field constraints

If *pydantic* finds constraints which are not being enforced, an error will be raised. If you want to force the
constraint to appear in the schema, even though it's not being checked upon parsing, you can use variadic arguments
to `Field()` with the raw schema attribute name:

```py
{!.tmp_examples/schema_unenforced_constraints.py!}
```
_(This script is complete, it should run "as is")_

## Modifying schema in custom fields

Custom field types can customise the schema generated for them using the `__modify_schema__` class method;
see [Custom Data Types](types.md#custom-data-types) for more details.

## JSON Schema Types

Types, custom field types, and constraints (like `max_length`) are mapped to the corresponding spec formats in the
following priority order (when there is an equivalent available):

1. [JSON Schema Core](http://json-schema.org/latest/json-schema-core.html#rfc.section.4.3.1)
2. [JSON Schema Validation](http://json-schema.org/latest/json-schema-validation.html)
3. [OpenAPI Data Types](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#data-types)
4. The standard `format` JSON field is used to define *pydantic* extensions for more complex `string` sub-types.

The field schema mapping from Python / *pydantic* to JSON Schema is done as follows:

{!.tmp_schema_mappings.html!}

## Top-level schema generation

You can also generate a top-level JSON Schema that only includes a list of models and related
sub-models in its `definitions`:

```py
{!.tmp_examples/schema_top_level.py!}
```
_(This script is complete, it should run "as is")_

Outputs:

```json
{!.tmp_examples/schema_top_level.json!}
```

## Schema customization

You can customize the generated `$ref` JSON location: the definitions are always stored under the key
`definitions`, but a specified prefix can be used for the references.

This is useful if you need to extend or modify the JSON Schema default definitions location. E.g. with OpenAPI:

```py
{!.tmp_examples/schema_custom.py!}
```
_(This script is complete, it should run "as is")_

Outputs:

```json
{!.tmp_examples/schema_custom.json!}
```

It's also possible to extend/override the generated JSON schema in a model.

To do it, use the `Config` sub-class attribute `schema_extra`.

For example, you could add `examples` to the JSON Schema:

```py
{!.tmp_examples/schema_with_example.py!}
```
_(This script is complete, it should run "as is")_

Outputs:

```json
{!.tmp_examples/schema_with_example.json!}
```

For more fine-grained control, you can alternatively set `schema_extra` to a callable and post-process the generated schema.
The callable can have one or two positional arguments.
The first will be the schema dictionary.
The second, if accepted, will be the model class.
The callable is expected to mutate the schema dictionary *in-place*; the return value is not used.

For example, the `title` key can be removed from the model's `properties`:

```py
{!.tmp_examples/schema_extra_callable.py!}
```

_(This script is complete, it should run "as is")_

Outputs:

```json
{!.tmp_examples/schema_extra_callable.json!}
```
